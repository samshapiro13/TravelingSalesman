1. Make n routes: v0 →vi →v0,foreachi≥1;

2. Compute the savings for merging delivery locations i and j, which is given by sij =
di0 + d0j − dij , for all i, j ≥ 1 and i ̸= j;

3. Sort the savings in descending order;

4. Starting at the top of the (remaining) list of savings, merge the two routes associated with the largest (remaining) savings, provided that:
(a) The two delivery locations are not already on the same route;
(b) Neither delivery location is interior to its route, meaning that both notes are still directly connected to the depot on their respective routes;
(c) The demand G and distance constraints D are not violated by the merged route. 5. Repeat step (3) until no additional savings can be achieved.




for i ... nodes.length
	for j ... nodes.length
		distances[i][j] = distance(node[i].x,node[i].y,node[j].x, node[j].y) ///change format to get actual x & y values

savings = []
visited = []
for i ... distances.length
	for j ... distances.length
		if (distances[i][j] < min && i != j && distances[i][j] not in visited)
			min = distances[i][j]



